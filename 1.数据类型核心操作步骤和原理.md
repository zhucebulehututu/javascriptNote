## 数据类型的核心操作
    
    
### js中的数据类型
    
- 基本数据类型（值类型）
    + number
    + string
    + boolean
    + null
    + undefined
        
- 引用数据类型
    + 对象
        + {}普通对象
        + []数组
        + /^$/正则
        + Math 数学函数
        + ...
    + 函数
        + function 
        + 类
        + ...

---

    js代码运行在浏览器中，是因为浏览器给我们提供了一个供js代码执行的环境 -> ‘全局作用域（winodw）’

---

```JavaScript

var a = 12;
var b = a;
b = 13;
console.log(a); //12


var o = {name:'hulongfei'};
var p = o;
o.name = 'maxingchen';
console.log(o.name); //'maxingchen'


var m = {name:'hulongfei'};
var n = m;
n  = {name:'baiqingyuan'};
console.log(m.name); //'hulongfei'


任意数求和
function fn(){
    var arr = Array.prototype.slice.call(arguments);
    return eval(arr.join('+'));
}
fn(11,22,33,44,55); //165
```

### 值类型
>直接按值操作，例如：var a = 12;直接把12这个值
>赋值给变量a,(让a变量和12这个值建立了链接关系)

### 对象数据类型
>在js中遇到对象，会严格按照如下的步骤操作：

>1.浏览器为其开辟一个新的内存空间，为了方便后期可以找到这个空间，浏览器给空间分配一个16进制的地址

>2.按照一定顺序，分别的把对象键值对存储到内存空间中

>3.把开辟内存的地址赋值给变量（其他的东西），以后变量就可以通过地址找到内存空间，然后进行一些操作。

### 函数的操作
>创建函数

>1.先开辟一个新的内存空间（为其分配了一个16进制的地址）

>2.把函数体中的js代码当成‘字符串’存储到空间当中（函数只创建不执行没有任何意义）

>3.把分配的地址赋值给声明的函数名（function fn和var fn操作原理其实相同，都是在当前作用域声明了一个名字，此处两个名字是重复的，function声明在预解析的时候是声明和定义都一起完成，所以在任何地方都可以调用）


>执行函数

>目的：执行函数体中的代码

>1.函数执行的时候，浏览器会形成一个新的私有作用域（只能执行函数体重的代码），供函数体中的代码执行。

>2.执行代码之前，先把创建函数存储的那些字符串变为真正的js表达式，按照从上到下的顺序在私有作用域中执行

>一个函数可以被执行n次，每一次执行相互之间互不干扰（后面会学习两者之间建立的间接关系）

>形成的私有作用域把函数体中的私有变量等都保护起来了，在私有作用域操作私有变量和外界没有关系，外界也无法直接的操作私有变量，我们把函数执行形成的这种保护机制叫做‘闭包’



---

## 堆栈内存及内存释放

>栈内存：
>
>俗称叫做作用域（全局作用域window/私有作用域）
>
>为js代码提供执行的环境（执行js代码的地方）
>
>基本数据类型的值是直接存放在栈内存中的



>堆内存：
>
>存储引用数据类型的值（相当于一个存储的仓库）
>
>对象存储的是键值对
>
>函数存储的是代码字符串

>在项目中，我们的内存越少性能越好，我们需要把一些没有的内存处理掉

>[堆内存]

>var o ={};当前对象对应的堆内存被变量o占用，堆内存无法销毁
o =null; nul空对象指针（不指向任何的堆内存），此时上一次的堆内存就没有被占用了，谷歌浏览器会在空闲的时间把没有占用的堆内存自动释放（销毁/回收）

>[栈内存]

>一般情况下，函数执行形成栈内存，函数执行完，浏览器会把形成的栈内存自动释放；

>有时候执行完成，栈内存不能被释放？

>全局作用域在加载页面的时候执行，在关掉页面的时候销毁