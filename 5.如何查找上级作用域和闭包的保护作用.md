## 如何查找上级作用域

>函数执行形成一个私有的作用域（A），A的上级作用域是谁，和他在哪执行的没关系，主要看在哪定义的，在哪个作用域定义的，当前A的作用域就是谁；
```javascript
var n = 10;
function sum(){
    console.log(n);
}
sum(); //10

~function (){
    var n =100;
    sum(); //10， 宿主环境
}();


var n = 10;
var obj = {
    n:20,
    fn:(function (){
        var n = 30;
        //上级作用域是全局作用域
        return function (){
            //上级作用域是自执行函数
            console.log(n);
        }
    })();
};
obj.fn();//30





var n = 10;
var obj = {
    n:20,
    fn:(function (){
        return function (){
            console.log(n);
        }
    })();
};
obj.fn();//10




var n = 10;
var obj = {
    n:20,
    fn:(function (n){
        return function (){
            console.log(n);
        }
    })(obj.n);
};
obj.fn();//报错
```

## 闭包作用（保护）
>形成私有作用域，保护里面的私有变量不受外界干扰 
jQuery:常用的js类库，提供了很多项目中常用的方法（兼容所有浏览器）
Zepto:小型jq，专门为移动端开发准备的

```javascript
//jq代码片段
(function(window,undefined){
    var jQuery = function(){
        ...
    };
    ...
    window.jQuery = window.$ = jQuery;
})();
jQuery();
$();


//zepto代码片段
var Zepto = (function(){
    var zepto = function(){
        ...
    }
    ...
    return zepto;
})();
var $ = Zepto;
Zepto();
$();
```
>真实项目中，我们利用这种保护机制，实现团队协作开发；（避免了多人同一个命名，导致冲突的问题）
```javascript
//A
~(function(){
    function fn(){
        
    };
    window.fn = fn;
    ...
})();

//B
~(function(){
    function fn(){
        
    };
    //B想要调取A写的fn
    window.fn();
})();
```